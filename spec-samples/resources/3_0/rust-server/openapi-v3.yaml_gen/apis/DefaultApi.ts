/**
 * My title
 * API under test
 *
 * The version of the OpenAPI document: 1.0.7
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

import type {
  UrlQueryInput,
  OperationConfiguration,
  RequestConfiguration,
  ResponseConfiguration,
  FetchParameters,
} from '@rocket-scripts/openapi';
import {
  pipe,
  collectionFormats,
  querystring,
  fetchRequest,
  APIRequestError,
  APIExceptionError,
} from '@rocket-scripts/openapi';
import type {
  AnotherXmlObject,
  DuplicateXmlObject,
  InlineResponse201,
  ModelString,
  ObjectParam,
  ObjectUntypedProps,
  ObjectWithArrayOfObjects,
  StringEnum,
  XmlObject,
} from '../models';
import { typeSerializer } from '../runtime';

/* eslint-disable */

export interface CallbackWithHeaderPostRequestParameters {
  url: string;
}
export interface ComplexQueryParamGetRequestParameters {
  listOfStrings?: Array<string>;
}
export interface EnumInPathPathParamGetRequestParameters {
  pathParam: StringEnum;
}
export interface JsonComplexQueryParamGetRequestParameters {
  listOfStrings?: Array<string>;
}
export interface MandatoryRequestHeaderGetRequestParameters {
  xHeader: string;
}
export interface ParamgetGetRequestParameters {
  uuid?: string;
  someObject?: ObjectParam;
  someList?: Array<number>;
}
export interface RegisterCallbackPostRequestParameters {
  url: string;
}
export interface RequiredOctetStreamPutRequestParameters {
  body: string;
}
export interface UntypedPropertyGetRequestParameters {
  objectUntypedProps?: ObjectUntypedProps;
}
export interface XmlExtraPostRequestParameters {
  duplicateXmlObject?: DuplicateXmlObject;
}
export interface XmlOtherPostRequestParameters {
  anotherXmlObject?: AnotherXmlObject;
}
export interface XmlOtherPutRequestParameters {
  requestBody?: Array<string>;
}
export interface XmlPostRequestParameters {
  requestBody?: Array<string>;
}
export interface XmlPutRequestParameters {
  xmlObject?: XmlObject;
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const callbackWithHeaderPostRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: CallbackWithHeaderPostRequestParameters,
): FetchParameters => {
  if (requestParameters.url === null || requestParameters.url === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.url was null or undefined when calling callbackWithHeaderPost.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.url !== undefined) {
    queryParameters['url'] = requestParameters.url;
  }

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/callback-with-header`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'POST',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const callbackWithHeaderPostResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function callbackWithHeaderPost(
  requestParameters: CallbackWithHeaderPostRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    callbackWithHeaderPostRequest(configuration),
    fetchRequest(configuration),
    callbackWithHeaderPostResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const complexQueryParamGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: ComplexQueryParamGetRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  if (requestParameters.listOfStrings) {
    queryParameters['list-of-strings'] = requestParameters.listOfStrings;
  }

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/complex-query-param`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const complexQueryParamGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function complexQueryParamGet(
  requestParameters: ComplexQueryParamGetRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    complexQueryParamGetRequest(configuration),
    fetchRequest(configuration),
    complexQueryParamGetResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const enumInPathPathParamGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: EnumInPathPathParamGetRequestParameters,
): FetchParameters => {
  if (
    requestParameters.pathParam === null ||
    requestParameters.pathParam === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.pathParam was null or undefined when calling enumInPathPathParamGet.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/enum_in_path/{path_param}`.replace(
    `{${'path_param'}}`,
    encodeURIComponent(String(requestParameters.pathParam)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const enumInPathPathParamGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function enumInPathPathParamGet(
  requestParameters: EnumInPathPathParamGetRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    enumInPathPathParamGetRequest(configuration),
    fetchRequest(configuration),
    enumInPathPathParamGetResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const jsonComplexQueryParamGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: JsonComplexQueryParamGetRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  if (requestParameters.listOfStrings) {
    queryParameters['list-of-strings'] = requestParameters.listOfStrings;
  }

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/json-complex-query-param`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const jsonComplexQueryParamGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function jsonComplexQueryParamGet(
  requestParameters: JsonComplexQueryParamGetRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    jsonComplexQueryParamGetRequest(configuration),
    fetchRequest(configuration),
    jsonComplexQueryParamGetResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const mandatoryRequestHeaderGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: MandatoryRequestHeaderGetRequestParameters,
): FetchParameters => {
  if (
    requestParameters.xHeader === null ||
    requestParameters.xHeader === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.xHeader was null or undefined when calling mandatoryRequestHeaderGet.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  if (
    requestParameters.xHeader !== undefined &&
    requestParameters.xHeader !== null
  ) {
    headerParameters.set('X-Header', String(requestParameters.xHeader));
  }

  let url: string = `${basePath.replace(/\/+$/, '')}/mandatory-request-header`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const mandatoryRequestHeaderGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function mandatoryRequestHeaderGet(
  requestParameters: MandatoryRequestHeaderGetRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    mandatoryRequestHeaderGetRequest(configuration),
    fetchRequest(configuration),
    mandatoryRequestHeaderGetResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const mergePatchJsonGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/merge-patch-json`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const mergePatchJsonGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<AnotherXmlObject> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObject('AnotherXmlObject'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function mergePatchJsonGet(
  configuration: OperationConfiguration = {},
): Promise<AnotherXmlObject> {
  return pipe(
    mergePatchJsonGetRequest(configuration),
    fetchRequest(configuration),
    mergePatchJsonGetResponse(configuration),
  )();
}

/**
 * Get some stuff.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const multigetGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/multiget`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Get some stuff.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const multigetGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<AnotherXmlObject> => {
  if (response.status >= 200 && response.status < 300) {
    return response.blob();
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Get some stuff.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function multigetGet(
  configuration: OperationConfiguration = {},
): Promise<AnotherXmlObject> {
  return pipe(
    multigetGetRequest(configuration),
    fetchRequest(configuration),
    multigetGetResponse(configuration),
  )();
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const multipleAuthSchemeGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  if (accessToken) {
    // oauth required
    if (typeof accessToken === 'function') {
      headerParameters.set(
        'Authorization',
        accessToken('authScheme', ['test.read', 'test.write']),
      );
    } else {
      headerParameters.set('Authorization', accessToken);
    }
  }

  let url: string = `${basePath.replace(/\/+$/, '')}/multiple_auth_scheme`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const multipleAuthSchemeGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function multipleAuthSchemeGet(
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    multipleAuthSchemeGetRequest(configuration),
    fetchRequest(configuration),
    multipleAuthSchemeGetResponse(configuration),
  )();
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const overrideServerGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/override-server`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const overrideServerGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function overrideServerGet(
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    overrideServerGetRequest(configuration),
    fetchRequest(configuration),
    overrideServerGetResponse(configuration),
  )();
}

/**
 * Get some stuff with parameters.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const paramgetGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: ParamgetGetRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  if (requestParameters.uuid !== undefined) {
    queryParameters['uuid'] = requestParameters.uuid;
  }
  if (requestParameters.someObject !== undefined) {
    queryParameters['someObject'] = requestParameters.someObject;
  }
  if (requestParameters.someList) {
    queryParameters['someList'] = requestParameters.someList.join(
      collectionFormats['csv'],
    );
  }

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/paramget`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Get some stuff with parameters.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const paramgetGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<AnotherXmlObject> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObject('AnotherXmlObject'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Get some stuff with parameters.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function paramgetGet(
  requestParameters: ParamgetGetRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<AnotherXmlObject> {
  return pipe(
    paramgetGetRequest(configuration),
    fetchRequest(configuration),
    paramgetGetResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const readonlyAuthSchemeGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  if (accessToken) {
    // oauth required
    if (typeof accessToken === 'function') {
      headerParameters.set(
        'Authorization',
        accessToken('authScheme', ['test.read']),
      );
    } else {
      headerParameters.set('Authorization', accessToken);
    }
  }

  let url: string = `${basePath.replace(/\/+$/, '')}/readonly_auth_scheme`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const readonlyAuthSchemeGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function readonlyAuthSchemeGet(
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    readonlyAuthSchemeGetRequest(configuration),
    fetchRequest(configuration),
    readonlyAuthSchemeGetResponse(configuration),
  )();
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const registerCallbackPostRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: RegisterCallbackPostRequestParameters,
): FetchParameters => {
  if (requestParameters.url === null || requestParameters.url === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.url was null or undefined when calling registerCallbackPost.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.url !== undefined) {
    queryParameters['url'] = requestParameters.url;
  }

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/register-callback`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'POST',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const registerCallbackPostResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function registerCallbackPost(
  requestParameters: RegisterCallbackPostRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    registerCallbackPostRequest(configuration),
    fetchRequest(configuration),
    registerCallbackPostResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const requiredOctetStreamPutRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: RequiredOctetStreamPutRequestParameters,
): FetchParameters => {
  if (requestParameters.body === null || requestParameters.body === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.body was null or undefined when calling requiredOctetStreamPut.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/octet-stream');

  let url: string = `${basePath.replace(/\/+$/, '')}/required_octet_stream`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = requestParameters.body as any;

  return {
    input: url,
    init: {
      method: 'PUT',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const requiredOctetStreamPutResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function requiredOctetStreamPut(
  requestParameters: RequiredOctetStreamPutRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    requiredOctetStreamPutRequest(configuration),
    fetchRequest(configuration),
    requiredOctetStreamPutResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const responsesWithHeadersGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/responses_with_headers`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const responsesWithHeadersGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<ModelString> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('ModelString'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function responsesWithHeadersGet(
  configuration: OperationConfiguration = {},
): Promise<ModelString> {
  return pipe(
    responsesWithHeadersGetRequest(configuration),
    fetchRequest(configuration),
    responsesWithHeadersGetResponse(configuration),
  )();
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const rfc7807GetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/rfc7807`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const rfc7807GetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<ObjectWithArrayOfObjects> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObject('ObjectWithArrayOfObjects'));
  } else {
    switch (response.status.toString()) {
      case '404': // NotFound
        throw new APIExceptionError({
          exception: typeSerializer.toValueObject('ObjectWithArrayOfObjects')(
            await response.json(),
          ),
          message: `NotFound`,
          response,
        });
      case '406': // NotAcceptable
        throw new APIExceptionError({
          exception: typeSerializer.toValueObject('ObjectWithArrayOfObjects')(
            await response.json(),
          ),
          message: `NotAcceptable`,
          response,
        });
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function rfc7807Get(
  configuration: OperationConfiguration = {},
): Promise<ObjectWithArrayOfObjects> {
  return pipe(
    rfc7807GetRequest(configuration),
    fetchRequest(configuration),
    rfc7807GetResponse(configuration),
  )();
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const untypedPropertyGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: UntypedPropertyGetRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/json');

  let url: string = `${basePath.replace(/\/+$/, '')}/untyped_property`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('ObjectUntypedProps')(
      requestParameters.objectUntypedProps,
    ),
  );

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const untypedPropertyGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function untypedPropertyGet(
  requestParameters: UntypedPropertyGetRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    untypedPropertyGetRequest(configuration),
    fetchRequest(configuration),
    untypedPropertyGetResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const uuidGetRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/uuid`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const uuidGetResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<string> => {
  if (response.status >= 200 && response.status < 300) {
    return response.text().then(typeSerializer.toValueObject('string'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function uuidGet(
  configuration: OperationConfiguration = {},
): Promise<string> {
  return pipe(
    uuidGetRequest(configuration),
    fetchRequest(configuration),
    uuidGetResponse(configuration),
  )();
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlExtraPostRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: XmlExtraPostRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/xml');

  let url: string = `${basePath.replace(/\/+$/, '')}/xml_extra`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('DuplicateXmlObject')(
      requestParameters.duplicateXmlObject,
    ),
  );

  return {
    input: url,
    init: {
      method: 'POST',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlExtraPostResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function xmlExtraPost(
  requestParameters: XmlExtraPostRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    xmlExtraPostRequest(configuration),
    fetchRequest(configuration),
    xmlExtraPostResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlOtherPostRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: XmlOtherPostRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'text/xml');

  let url: string = `${basePath.replace(/\/+$/, '')}/xml_other`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('AnotherXmlObject')(
      requestParameters.anotherXmlObject,
    ),
  );

  return {
    input: url,
    init: {
      method: 'POST',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlOtherPostResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<AnotherXmlObject> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObject('AnotherXmlObject'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function xmlOtherPost(
  requestParameters: XmlOtherPostRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<AnotherXmlObject> {
  return pipe(
    xmlOtherPostRequest(configuration),
    fetchRequest(configuration),
    xmlOtherPostResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlOtherPutRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: XmlOtherPutRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/xml');

  let url: string = `${basePath.replace(/\/+$/, '')}/xml_other`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(requestParameters.requestBody);

  return {
    input: url,
    init: {
      method: 'PUT',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlOtherPutResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function xmlOtherPut(
  requestParameters: XmlOtherPutRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    xmlOtherPutRequest(configuration),
    fetchRequest(configuration),
    xmlOtherPutResponse(configuration),
  )(requestParameters);
}

/**
 * Post an array
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlPostRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: XmlPostRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/xml');

  let url: string = `${basePath.replace(/\/+$/, '')}/xml`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(requestParameters.requestBody);

  return {
    input: url,
    init: {
      method: 'POST',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Post an array
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlPostResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Post an array
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function xmlPost(
  requestParameters: XmlPostRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    xmlPostRequest(configuration),
    fetchRequest(configuration),
    xmlPostResponse(configuration),
  )(requestParameters);
}

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlPutRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: XmlPutRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/xml');

  let url: string = `${basePath.replace(/\/+$/, '')}/xml`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('XmlObject')(requestParameters.xmlObject),
  );

  return {
    input: url,
    init: {
      method: 'PUT',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const xmlPutResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<void> => {
  if (response.status >= 200 && response.status < 300) {
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function xmlPut(
  requestParameters: XmlPutRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<void> {
  return pipe(
    xmlPutRequest(configuration),
    fetchRequest(configuration),
    xmlPutResponse(configuration),
  )(requestParameters);
}

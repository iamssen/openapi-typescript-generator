/**
 * time@work rest api
 * internal rest api, used by time@work angular client
 *
 * The version of the OpenAPI document: 0.1
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

import type {
  UrlQueryInput,
  OperationConfiguration,
  RequestConfiguration,
  ResponseConfiguration,
  FetchParameters,
} from '@rocket-scripts/openapi';
import {
  pipe,
  collectionFormats,
  querystring,
  fetchRequest,
  APIRequestError,
  APIExceptionError,
} from '@rocket-scripts/openapi';
import type {
  CProject,
  CTask,
  CTaskAssignment,
  CTeamMember,
  InlineResponse400,
  InlineResponse4001,
  ResponseStatusException,
  Task,
} from '../models';
import { typeSerializer } from '../runtime';

/* eslint-disable */

export interface ChangeAssignmentRequestParameters {
  taskId: number;
  assignmentId: number;
  cTaskAssignment?: CTaskAssignment;
}
export interface ChangeProjectRequestParameters {
  projectId: number;
  cProject?: CProject;
}
export interface ChangeTaskRequestParameters {
  taskId: number;
  cTask?: CTask;
}
export interface CreateAssignmentRequestParameters {
  taskId: number;
  cTaskAssignment?: CTaskAssignment;
}
export interface CreateProjectRequestParameters {
  cProject?: CProject;
}
export interface CreateTaskForProjectRequestParameters {
  projectId: number;
  cTask?: CTask;
}
export interface DeleteAssignmentRequestParameters {
  taskId: number;
  assignmentId: number;
}
export interface DeleteTaskRequestParameters {
  taskId: number;
}
export interface GetProjectRequestParameters {
  projectId: number;
}
export interface GetProjectTasksRequestParameters {
  projectId: number;
}
export interface GetTaskRequestParameters {
  taskId: number;
}
export interface GetTaskAssignmentsRequestParameters {
  taskId: number;
}

/**
 * change from/until of given assignment
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const changeAssignmentRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: ChangeAssignmentRequestParameters,
): FetchParameters => {
  if (
    requestParameters.taskId === null ||
    requestParameters.taskId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.taskId was null or undefined when calling changeAssignment.`,
    );
  }
  if (
    requestParameters.assignmentId === null ||
    requestParameters.assignmentId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.assignmentId was null or undefined when calling changeAssignment.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/json');

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/task/{taskId}/assignment/{assignmentId}`
    .replace(
      `{${'taskId'}}`,
      encodeURIComponent(String(requestParameters.taskId)),
    )
    .replace(
      `{${'assignmentId'}}`,
      encodeURIComponent(String(requestParameters.assignmentId)),
    );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('CTaskAssignment')(
      requestParameters.cTaskAssignment,
    ),
  );

  return {
    input: url,
    init: {
      method: 'PUT',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * change from/until of given assignment
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const changeAssignmentResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<CTaskAssignment> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObject('CTaskAssignment'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * change from/until of given assignment
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function changeAssignment(
  requestParameters: ChangeAssignmentRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<CTaskAssignment> {
  return pipe(
    changeAssignmentRequest(configuration),
    fetchRequest(configuration),
    changeAssignmentResponse(configuration),
  )(requestParameters);
}

/**
 * change an existing project.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const changeProjectRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: ChangeProjectRequestParameters,
): FetchParameters => {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.projectId was null or undefined when calling changeProject.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/json');

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/project/{projectId}`.replace(
    `{${'projectId'}}`,
    encodeURIComponent(String(requestParameters.projectId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('CProject')(requestParameters.cProject),
  );

  return {
    input: url,
    init: {
      method: 'PUT',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * change an existing project.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const changeProjectResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<CProject> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('CProject'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * change an existing project.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function changeProject(
  requestParameters: ChangeProjectRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<CProject> {
  return pipe(
    changeProjectRequest(configuration),
    fetchRequest(configuration),
    changeProjectResponse(configuration),
  )(requestParameters);
}

/**
 * change an existing task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const changeTaskRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: ChangeTaskRequestParameters,
): FetchParameters => {
  if (
    requestParameters.taskId === null ||
    requestParameters.taskId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.taskId was null or undefined when calling changeTask.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/json');

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/task/{taskId}`.replace(
    `{${'taskId'}}`,
    encodeURIComponent(String(requestParameters.taskId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('CTask')(requestParameters.cTask),
  );

  return {
    input: url,
    init: {
      method: 'PUT',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * change an existing task.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const changeTaskResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Task> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('Task'));
  } else {
    switch (response.status.toString()) {
      case '400': // inline schema2
        throw new APIExceptionError({
          exception: typeSerializer.toValueObject('InlineResponse4001')(
            await response.json(),
          ),
          message: `inline schema2`,
          response,
        });
      default:
        throw response;
    }
  }
};

/**
 * change an existing task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function changeTask(
  requestParameters: ChangeTaskRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Task> {
  return pipe(
    changeTaskRequest(configuration),
    fetchRequest(configuration),
    changeTaskResponse(configuration),
  )(requestParameters);
}

/**
 * add a new assignment to an existing task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const createAssignmentRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: CreateAssignmentRequestParameters,
): FetchParameters => {
  if (
    requestParameters.taskId === null ||
    requestParameters.taskId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.taskId was null or undefined when calling createAssignment.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/json');

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/task/{taskId}/assignment`.replace(
    `{${'taskId'}}`,
    encodeURIComponent(String(requestParameters.taskId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('CTaskAssignment')(
      requestParameters.cTaskAssignment,
    ),
  );

  return {
    input: url,
    init: {
      method: 'POST',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * add a new assignment to an existing task.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const createAssignmentResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<CTaskAssignment> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObject('CTaskAssignment'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * add a new assignment to an existing task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function createAssignment(
  requestParameters: CreateAssignmentRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<CTaskAssignment> {
  return pipe(
    createAssignmentRequest(configuration),
    fetchRequest(configuration),
    createAssignmentResponse(configuration),
  )(requestParameters);
}

/**
 * create a new project.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const createProjectRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: CreateProjectRequestParameters,
): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/json');

  let url: string = `${basePath.replace(/\/+$/, '')}/rest/project/`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('CProject')(requestParameters.cProject),
  );

  return {
    input: url,
    init: {
      method: 'POST',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * create a new project.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const createProjectResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<CProject> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('CProject'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * create a new project.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function createProject(
  requestParameters: CreateProjectRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<CProject> {
  return pipe(
    createProjectRequest(configuration),
    fetchRequest(configuration),
    createProjectResponse(configuration),
  )(requestParameters);
}

/**
 * create a new task for an existing project
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const createTaskForProjectRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: CreateTaskForProjectRequestParameters,
): FetchParameters => {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.projectId was null or undefined when calling createTaskForProject.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  headerParameters.set('Content-Type', 'application/json');

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/project/{projectId}/task`.replace(
    `{${'projectId'}}`,
    encodeURIComponent(String(requestParameters.projectId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = JSON.stringify(
    typeSerializer.toJsonObject('CTask')(requestParameters.cTask),
  );

  return {
    input: url,
    init: {
      method: 'POST',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * create a new task for an existing project
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const createTaskForProjectResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<CTask> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('CTask'));
  } else {
    switch (response.status.toString()) {
      case '403': // not authorized as project lead or admin
        throw new APIExceptionError({
          exception: typeSerializer.toValueObject('CTask')(
            await response.json(),
          ),
          message: `not authorized as project lead or admin`,
          response,
        });
      case '4XX': // ????
        throw new APIExceptionError({
          exception: typeSerializer.toValueObject('string')(
            await response.json(),
          ),
          message: `????`,
          response,
        });
      case '404': // project not found
        throw new APIExceptionError({
          exception: typeSerializer.toValueObject('ResponseStatusException')(
            await response.json(),
          ),
          message: `project not found`,
          response,
        });
      default:
        throw response;
    }
  }
};

/**
 * create a new task for an existing project
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function createTaskForProject(
  requestParameters: CreateTaskForProjectRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<CTask> {
  return pipe(
    createTaskForProjectRequest(configuration),
    fetchRequest(configuration),
    createTaskForProjectResponse(configuration),
  )(requestParameters);
}

/**
 * delete an existing assignment from task
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const deleteAssignmentRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: DeleteAssignmentRequestParameters,
): FetchParameters => {
  if (
    requestParameters.taskId === null ||
    requestParameters.taskId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.taskId was null or undefined when calling deleteAssignment.`,
    );
  }
  if (
    requestParameters.assignmentId === null ||
    requestParameters.assignmentId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.assignmentId was null or undefined when calling deleteAssignment.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/task/{taskId}/assignment/{assignmentId}`
    .replace(
      `{${'taskId'}}`,
      encodeURIComponent(String(requestParameters.taskId)),
    )
    .replace(
      `{${'assignmentId'}}`,
      encodeURIComponent(String(requestParameters.assignmentId)),
    );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'DELETE',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * delete an existing assignment from task
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const deleteAssignmentResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<number> => {
  if (response.status >= 200 && response.status < 300) {
    return response.text().then(typeSerializer.toValueObject('number'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * delete an existing assignment from task
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function deleteAssignment(
  requestParameters: DeleteAssignmentRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<number> {
  return pipe(
    deleteAssignmentRequest(configuration),
    fetchRequest(configuration),
    deleteAssignmentResponse(configuration),
  )(requestParameters);
}

/**
 * delete an existing task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const deleteTaskRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: DeleteTaskRequestParameters,
): FetchParameters => {
  if (
    requestParameters.taskId === null ||
    requestParameters.taskId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.taskId was null or undefined when calling deleteTask.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/task/{taskId}`.replace(
    `{${'taskId'}}`,
    encodeURIComponent(String(requestParameters.taskId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'DELETE',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * delete an existing task.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const deleteTaskResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<number> => {
  if (response.status >= 200 && response.status < 300) {
    return response.text().then(typeSerializer.toValueObject('number'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * delete an existing task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function deleteTask(
  requestParameters: DeleteTaskRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<number> {
  return pipe(
    deleteTaskRequest(configuration),
    fetchRequest(configuration),
    deleteTaskResponse(configuration),
  )(requestParameters);
}

/**
 * retrieving a specific visible projects for current user.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getProjectRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetProjectRequestParameters,
): FetchParameters => {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.projectId was null or undefined when calling getProject.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/project/{projectId}`.replace(
    `{${'projectId'}}`,
    encodeURIComponent(String(requestParameters.projectId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * retrieving a specific visible projects for current user.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getProjectResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<CProject> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('CProject'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * retrieving a specific visible projects for current user.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getProject(
  requestParameters: GetProjectRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<CProject> {
  return pipe(
    getProjectRequest(configuration),
    fetchRequest(configuration),
    getProjectResponse(configuration),
  )(requestParameters);
}

/**
 * retrieving tasks for a specific project.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getProjectTasksRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetProjectTasksRequestParameters,
): FetchParameters => {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.projectId was null or undefined when calling getProjectTasks.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/project/{projectId}/task`.replace(
    `{${'projectId'}}`,
    encodeURIComponent(String(requestParameters.projectId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * retrieving tasks for a specific project.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getProjectTasksResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<CTask>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObjectList('CTask'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * retrieving tasks for a specific project.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getProjectTasks(
  requestParameters: GetProjectTasksRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<CTask>> {
  return pipe(
    getProjectTasksRequest(configuration),
    fetchRequest(configuration),
    getProjectTasksResponse(configuration),
  )(requestParameters);
}

/**
 * retrieving all visible projects for current user.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getProjectsRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/rest/project/`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * retrieving all visible projects for current user.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getProjectsResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<CProject>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObjectList('CProject'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * retrieving all visible projects for current user.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getProjects(
  configuration: OperationConfiguration = {},
): Promise<Array<CProject>> {
  return pipe(
    getProjectsRequest(configuration),
    fetchRequest(configuration),
    getProjectsResponse(configuration),
  )();
}

/**
 * retrieving a specific task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTaskRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetTaskRequestParameters,
): FetchParameters => {
  if (
    requestParameters.taskId === null ||
    requestParameters.taskId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.taskId was null or undefined when calling getTask.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/task/{taskId}`.replace(
    `{${'taskId'}}`,
    encodeURIComponent(String(requestParameters.taskId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * retrieving a specific task.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTaskResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<CTask> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('CTask'));
  } else {
    switch (response.status.toString()) {
      case '400': // inline schema
        throw new APIExceptionError({
          exception: typeSerializer.toValueObject('InlineResponse400')(
            await response.json(),
          ),
          message: `inline schema`,
          response,
        });
      default:
        throw response;
    }
  }
};

/**
 * retrieving a specific task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getTask(
  requestParameters: GetTaskRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<CTask> {
  return pipe(
    getTaskRequest(configuration),
    fetchRequest(configuration),
    getTaskResponse(configuration),
  )(requestParameters);
}

/**
 * retrieving team member assignments for a specific task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTaskAssignmentsRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetTaskAssignmentsRequestParameters,
): FetchParameters => {
  if (
    requestParameters.taskId === null ||
    requestParameters.taskId === undefined
  ) {
    throw new APIRequestError(
      `Required parameter requestParameters.taskId was null or undefined when calling getTaskAssignments.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/rest/task/{taskId}/assignment`.replace(
    `{${'taskId'}}`,
    encodeURIComponent(String(requestParameters.taskId)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * retrieving team member assignments for a specific task.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTaskAssignmentsResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<CTaskAssignment>> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObjectList('CTaskAssignment'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * retrieving team member assignments for a specific task.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getTaskAssignments(
  requestParameters: GetTaskAssignmentsRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<CTaskAssignment>> {
  return pipe(
    getTaskAssignmentsRequest(configuration),
    fetchRequest(configuration),
    getTaskAssignmentsResponse(configuration),
  )(requestParameters);
}

/**
 * retrieving all known users.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTeamMembersRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (): FetchParameters => {
  const queryParameters: UrlQueryInput = {};

  const headerParameters: Headers = new Headers(headers);

  let url: string = `${basePath.replace(/\/+$/, '')}/rest/teammember`;
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * retrieving all known users.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTeamMembersResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<CTeamMember>> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObjectList('CTeamMember'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * retrieving all known users.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getTeamMembers(
  configuration: OperationConfiguration = {},
): Promise<Array<CTeamMember>> {
  return pipe(
    getTeamMembersRequest(configuration),
    fetchRequest(configuration),
    getTeamMembersResponse(configuration),
  )();
}

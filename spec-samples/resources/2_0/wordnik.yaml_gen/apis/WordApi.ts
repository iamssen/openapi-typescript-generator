/**
 * The Wordnik Public API
 * **Wordnik has an API, and you\'re invited.** The Wordnik API lets you request definitions, example sentences, spelling suggestions,  related words like synonyms and antonyms, phrases containing a given word, word  autocompletion, random words, words of the day, and much more
 *
 * The version of the OpenAPI document: 4.0.1
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

import type {
  UrlQueryInput,
  OperationConfiguration,
  RequestConfiguration,
  ResponseConfiguration,
  FetchParameters,
} from '@rocket-scripts/openapi';
import {
  pipe,
  collectionFormats,
  querystring,
  fetchRequest,
  APIRequestError,
  APIExceptionError,
} from '@rocket-scripts/openapi';
import type {
  AudioFile,
  Bigram,
  Definition,
  Example,
  ExampleSearchResults,
  FrequencySummary,
  Related,
  Syllable,
  TextPron,
  WordObject,
} from '../models';
import { typeSerializer } from '../runtime';

/* eslint-disable */

export interface GetAudioRequestParameters {
  word: string;
  useCanonical?: string;
  limit?: number;
}
export interface GetDefinitionsRequestParameters {
  word: string;
  limit?: number;
  partOfSpeech?: string;
  includeRelated?: string;
  sourceDictionaries?: Array<string>;
  useCanonical?: string;
  includeTags?: string;
}
export interface GetEtymologiesRequestParameters {
  word: string;
  useCanonical?: string;
}
export interface GetExamplesRequestParameters {
  word: string;
  includeDuplicates?: string;
  useCanonical?: string;
  skip?: number;
  limit?: number;
}
export interface GetHyphenationRequestParameters {
  word: string;
  useCanonical?: string;
  sourceDictionary?: string;
  limit?: number;
}
export interface GetPhrasesRequestParameters {
  word: string;
  limit?: number;
  wlmi?: number;
  useCanonical?: string;
}
export interface GetRelatedWordsRequestParameters {
  word: string;
  useCanonical?: string;
  relationshipTypes?: string;
  limitPerRelationshipType?: number;
}
export interface GetTextPronunciationsRequestParameters {
  word: string;
  useCanonical?: string;
  sourceDictionary?: string;
  typeFormat?: string;
  limit?: number;
}
export interface GetTopExampleRequestParameters {
  word: string;
  useCanonical?: string;
}
export interface GetWordRequestParameters {
  word: string;
  useCanonical?: string;
  includeSuggestions?: string;
}
export interface GetWordFrequencyRequestParameters {
  word: string;
  useCanonical?: string;
  startYear?: number;
  endYear?: number;
}

/**
 * The metadata includes a time-expiring fileUrl which allows reading the audio file directly from the API.  Currently only audio pronunciations from the American Heritage Dictionary in mp3 format are supported.
 * Fetches audio metadata for a word.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getAudioRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetAudioRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getAudio.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/audio`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * The metadata includes a time-expiring fileUrl which allows reading the audio file directly from the API.  Currently only audio pronunciations from the American Heritage Dictionary in mp3 format are supported.
 * Fetches audio metadata for a word.
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getAudioResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<AudioFile>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObjectList('AudioFile'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * The metadata includes a time-expiring fileUrl which allows reading the audio file directly from the API.  Currently only audio pronunciations from the American Heritage Dictionary in mp3 format are supported.
 * Fetches audio metadata for a word.
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getAudio(
  requestParameters: GetAudioRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<AudioFile>> {
  return pipe(
    getAudioRequest(configuration),
    fetchRequest(configuration),
    getAudioResponse(configuration),
  )(requestParameters);
}

/**
 * Return definitions for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getDefinitionsRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetDefinitionsRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getDefinitions.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit;
  }
  if (requestParameters.partOfSpeech !== undefined) {
    queryParameters['partOfSpeech'] = requestParameters.partOfSpeech;
  }
  if (requestParameters.includeRelated !== undefined) {
    queryParameters['includeRelated'] = requestParameters.includeRelated;
  }
  if (requestParameters.sourceDictionaries) {
    queryParameters[
      'sourceDictionaries'
    ] = requestParameters.sourceDictionaries.join(collectionFormats['csv']);
  }
  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }
  if (requestParameters.includeTags !== undefined) {
    queryParameters['includeTags'] = requestParameters.includeTags;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/definitions`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Return definitions for a word
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getDefinitionsResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<Definition>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObjectList('Definition'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Return definitions for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getDefinitions(
  requestParameters: GetDefinitionsRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<Definition>> {
  return pipe(
    getDefinitionsRequest(configuration),
    fetchRequest(configuration),
    getDefinitionsResponse(configuration),
  )(requestParameters);
}

/**
 * Fetches etymology data
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getEtymologiesRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetEtymologiesRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getEtymologies.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/etymologies`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Fetches etymology data
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getEtymologiesResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<string>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json();
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Fetches etymology data
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getEtymologies(
  requestParameters: GetEtymologiesRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<string>> {
  return pipe(
    getEtymologiesRequest(configuration),
    fetchRequest(configuration),
    getEtymologiesResponse(configuration),
  )(requestParameters);
}

/**
 * Returns examples for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getExamplesRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetExamplesRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getExamples.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.includeDuplicates !== undefined) {
    queryParameters['includeDuplicates'] = requestParameters.includeDuplicates;
  }
  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }
  if (requestParameters.skip !== undefined) {
    queryParameters['skip'] = requestParameters.skip;
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/examples`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Returns examples for a word
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getExamplesResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<ExampleSearchResults> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObject('ExampleSearchResults'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Returns examples for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getExamples(
  requestParameters: GetExamplesRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<ExampleSearchResults> {
  return pipe(
    getExamplesRequest(configuration),
    fetchRequest(configuration),
    getExamplesResponse(configuration),
  )(requestParameters);
}

/**
 * Returns syllable information for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getHyphenationRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetHyphenationRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getHyphenation.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }
  if (requestParameters.sourceDictionary !== undefined) {
    queryParameters['sourceDictionary'] = requestParameters.sourceDictionary;
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/hyphenation`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Returns syllable information for a word
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getHyphenationResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<Syllable>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObjectList('Syllable'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Returns syllable information for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getHyphenation(
  requestParameters: GetHyphenationRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<Syllable>> {
  return pipe(
    getHyphenationRequest(configuration),
    fetchRequest(configuration),
    getHyphenationResponse(configuration),
  )(requestParameters);
}

/**
 * Fetches bi-gram phrases for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getPhrasesRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetPhrasesRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getPhrases.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit;
  }
  if (requestParameters.wlmi !== undefined) {
    queryParameters['wlmi'] = requestParameters.wlmi;
  }
  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/phrases`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Fetches bi-gram phrases for a word
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getPhrasesResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<Bigram>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObjectList('Bigram'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Fetches bi-gram phrases for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getPhrases(
  requestParameters: GetPhrasesRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<Bigram>> {
  return pipe(
    getPhrasesRequest(configuration),
    fetchRequest(configuration),
    getPhrasesResponse(configuration),
  )(requestParameters);
}

/**
 * Given a word as a string, returns relationships from the Word Graph
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getRelatedWordsRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetRelatedWordsRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getRelatedWords.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }
  if (requestParameters.relationshipTypes !== undefined) {
    queryParameters['relationshipTypes'] = requestParameters.relationshipTypes;
  }
  if (requestParameters.limitPerRelationshipType !== undefined) {
    queryParameters['limitPerRelationshipType'] =
      requestParameters.limitPerRelationshipType;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/relatedWords`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Given a word as a string, returns relationships from the Word Graph
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getRelatedWordsResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<Related>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObjectList('Related'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Given a word as a string, returns relationships from the Word Graph
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getRelatedWords(
  requestParameters: GetRelatedWordsRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<Related>> {
  return pipe(
    getRelatedWordsRequest(configuration),
    fetchRequest(configuration),
    getRelatedWordsResponse(configuration),
  )(requestParameters);
}

/**
 * Returns text pronunciations for a given word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTextPronunciationsRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetTextPronunciationsRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getTextPronunciations.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }
  if (requestParameters.sourceDictionary !== undefined) {
    queryParameters['sourceDictionary'] = requestParameters.sourceDictionary;
  }
  if (requestParameters.typeFormat !== undefined) {
    queryParameters['typeFormat'] = requestParameters.typeFormat;
  }
  if (requestParameters.limit !== undefined) {
    queryParameters['limit'] = requestParameters.limit;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/pronunciations`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Returns text pronunciations for a given word
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTextPronunciationsResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Array<TextPron>> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObjectList('TextPron'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Returns text pronunciations for a given word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getTextPronunciations(
  requestParameters: GetTextPronunciationsRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Array<TextPron>> {
  return pipe(
    getTextPronunciationsRequest(configuration),
    fetchRequest(configuration),
    getTextPronunciationsResponse(configuration),
  )(requestParameters);
}

/**
 * Returns a top example for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTopExampleRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetTopExampleRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getTopExample.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/topExample`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Returns a top example for a word
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getTopExampleResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<Example> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('Example'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Returns a top example for a word
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getTopExample(
  requestParameters: GetTopExampleRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<Example> {
  return pipe(
    getTopExampleRequest(configuration),
    fetchRequest(configuration),
    getTopExampleResponse(configuration),
  )(requestParameters);
}

/**
 * Given a word as a string, returns the WordObject that represents it
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getWordRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetWordRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getWord.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }
  if (requestParameters.includeSuggestions !== undefined) {
    queryParameters['includeSuggestions'] =
      requestParameters.includeSuggestions;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(/\/+$/, '')}/word.json/{word}`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Given a word as a string, returns the WordObject that represents it
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getWordResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<WordObject> => {
  if (response.status >= 200 && response.status < 300) {
    return response.json().then(typeSerializer.toValueObject('WordObject'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Given a word as a string, returns the WordObject that represents it
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getWord(
  requestParameters: GetWordRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<WordObject> {
  return pipe(
    getWordRequest(configuration),
    fetchRequest(configuration),
    getWordResponse(configuration),
  )(requestParameters);
}

/**
 * Returns word usage over time
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getWordFrequencyRequest = ({
  basePath = '',
  querystringStringify = querystring,
  username,
  password,
  apiKey,
  accessToken,
  headers,
  credentials,
}: RequestConfiguration = {}) => (
  requestParameters: GetWordFrequencyRequestParameters,
): FetchParameters => {
  if (requestParameters.word === null || requestParameters.word === undefined) {
    throw new APIRequestError(
      `Required parameter requestParameters.word was null or undefined when calling getWordFrequency.`,
    );
  }

  const queryParameters: UrlQueryInput = {};

  if (requestParameters.useCanonical !== undefined) {
    queryParameters['useCanonical'] = requestParameters.useCanonical;
  }
  if (requestParameters.startYear !== undefined) {
    queryParameters['startYear'] = requestParameters.startYear;
  }
  if (requestParameters.endYear !== undefined) {
    queryParameters['endYear'] = requestParameters.endYear;
  }

  const headerParameters: Headers = new Headers(headers);

  if (apiKey) {
    headerParameters.set('api_key', apiKey('api_key')); // apiKey authentication
  }

  let url: string = `${basePath.replace(
    /\/+$/,
    '',
  )}/word.json/{word}/frequency`.replace(
    `{${'word'}}`,
    encodeURIComponent(String(requestParameters.word)),
  );
  if (queryParameters && Object.keys(queryParameters).length > 0) {
    url += '?' + querystringStringify(queryParameters);
  }

  const body = undefined;

  return {
    input: url,
    init: {
      method: 'GET',
      headers: headerParameters,
      credentials,
      body,
    },
  };
};

/**
 * Returns word usage over time
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export const getWordFrequencyResponse = (
  configuration: ResponseConfiguration = {},
) => async (response: Response): Promise<FrequencySummary> => {
  if (response.status >= 200 && response.status < 300) {
    return response
      .json()
      .then(typeSerializer.toValueObject('FrequencySummary'));
  } else {
    switch (response.status.toString()) {
      default:
        throw response;
    }
  }
};

/**
 * Returns word usage over time
 * @throws {APIRequestError} throw when the request is not correct
 * @throws {APIExceptionError} throw when response is out of 2xx
 * @throws {Response} throw when the response.status is not accepted (fallback throwing)
 * @throws {APISerializeError} throw when fail serialize data (include request and response)
 */
export async function getWordFrequency(
  requestParameters: GetWordFrequencyRequestParameters,
  configuration: OperationConfiguration = {},
): Promise<FrequencySummary> {
  return pipe(
    getWordFrequencyRequest(configuration),
    fetchRequest(configuration),
    getWordFrequencyResponse(configuration),
  )(requestParameters);
}

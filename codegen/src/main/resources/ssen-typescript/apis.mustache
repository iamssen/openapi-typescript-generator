/* eslint-disable */
{{>licenseInfo}}

import { typeSerializer } from '../models';
import * as runtime from '../runtime';
import { APIExceptionError } from '@rocket-scripts/openapi';

{{#imports.0}}
import {
  {{#imports}}
  {{className}},
  {{/imports}}
} from '../models';
{{/imports.0}}

{{#operations}}
{{#operation}}
{{#allParams.0}}
export interface {{#prefixParameterInterfaces}}{{classname}}{{/prefixParameterInterfaces}}{{operationIdCamelCase}}Request {
  {{#allParams}}
  {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
  {{/allParams}}
}
{{/allParams.0}}
{{/operation}}
{{/operations}}

{{#operations}}
/**
 * {{#lambda.indented_star_1}}{{{unescapedDescription}}}{{/lambda.indented_star_1}}
 */
export class {{classname}} extends runtime.BaseAPI {
  {{#operation}}
  /**
   {{#notes}}
   * {{&notes}}
   {{/notes}}
   {{#summary}}
   * {{&summary}}
   {{/summary}}
   */
  {{nickname}}Request({{#allParams.0}}requestParameters: {{#prefixParameterInterfaces}}{{classname}}{{/prefixParameterInterfaces}}{{operationIdCamelCase}}Request{{/allParams.0}}): runtime.FetchParams {
    {{! check required }}
    {{#allParams}}
    {{#required}}
    if (requestParameters.{{paramName}} === null || requestParameters.{{paramName}} === undefined) {
      throw new runtime.RequiredError('{{paramName}}','Required parameter requestParameters.{{paramName}} was null or undefined when calling {{nickname}}.');
    }
    {{/required}}
    {{/allParams}}

    {{! query }}
    const queryParameters: runtime.HTTPQuery = {};

    {{#queryParams}}
    {{#isListContainer}}
    if (requestParameters.{{paramName}}) {
      {{#isCollectionFormatMulti}}
      queryParameters['{{baseName}}'] = requestParameters.{{paramName}};
      {{/isCollectionFormatMulti}}
      {{^isCollectionFormatMulti}}
      queryParameters['{{baseName}}'] = requestParameters.{{paramName}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]);
      {{/isCollectionFormatMulti}}
    }
    {{/isListContainer}}
    {{^isListContainer}}
    if (requestParameters.{{paramName}} !== undefined) {
      {{#isDateTime}}
      queryParameters['{{baseName}}'] = (requestParameters.{{paramName}} as any).toISOString();
      {{/isDateTime}}
      {{^isDateTime}}
      {{#isDate}}
      queryParameters['{{baseName}}'] = (requestParameters.{{paramName}} as any).toISOString().substr(0,10);
      {{/isDate}}
      {{^isDate}}
      queryParameters['{{baseName}}'] = requestParameters.{{paramName}};
      {{/isDate}}
      {{/isDateTime}}
    }
    {{/isListContainer}}
    {{/queryParams}}

    {{! header }}
    const headerParameters: runtime.HTTPHeaders = {};

    {{#bodyParam}}
    {{^consumes}}
    headerParameters['Content-Type'] = 'application/json';
    {{/consumes}}
    {{#consumes.0}}
    headerParameters['Content-Type'] = '{{{mediaType}}}';
    {{/consumes.0}}
    {{/bodyParam}}

    {{#headerParams}}
    {{#isListContainer}}
    if (requestParameters.{{paramName}}) {
      headerParameters['{{baseName}}'] = requestParameters.{{paramName}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]);
    }
    {{/isListContainer}}
    {{^isListContainer}}
    if (requestParameters.{{paramName}} !== undefined && requestParameters.{{paramName}} !== null) {
      headerParameters['{{baseName}}'] = String(requestParameters.{{paramName}});
    }
    {{/isListContainer}}
    {{/headerParams}}

    {{#authMethods}}

    {{#isBasic}}
    {{#isBasicBasic}}
    if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    {{/isBasicBasic}}
    {{#isBasicBearer}}
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === 'function' ? token("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    {{/isBasicBearer}}
    {{/isBasic}}

    {{#isApiKey}}
    {{#isKeyInHeader}}
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["{{keyParamName}}"] = this.configuration.apiKey("{{keyParamName}}"); // {{name}} authentication
    }
    {{/isKeyInHeader}}
    {{#isKeyInQuery}}
    if (this.configuration && this.configuration.apiKey) {
      queryParameters["{{keyParamName}}"] = this.configuration.apiKey("{{keyParamName}}"); // {{name}} authentication
    }
    {{/isKeyInQuery}}
    {{/isApiKey}}

    {{#isOAuth}}
    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      if (typeof this.configuration.accessToken === 'function') {
        headerParameters["Authorization"] = this.configuration.accessToken("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }
    {{/isOAuth}}
    {{/authMethods}}

    {{! form }}
    {{#hasFormParams}}
    const consumes: runtime.Consume[] = [
      {{#consumes}}
      { contentType: '{{{mediaType}}}' },
      {{/consumes}}
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;

    {{#formParams}}
    {{#isFile}}
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm;
    {{/isFile}}
    {{/formParams}}

    if (useForm) {
        formParams = new FormData();
    } else {
        formParams = new URLSearchParams();
    }

    {{#formParams}}
    {{#isListContainer}}
    if (requestParameters.{{paramName}}) {
      {{#isCollectionFormatMulti}}
      requestParameters.{{paramName}}.forEach((element) => {
        formParams.append('{{baseName}}', element as any);
      })
      {{/isCollectionFormatMulti}}
      {{^isCollectionFormatMulti}}
      formParams.append('{{baseName}}', requestParameters.{{paramName}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]));
      {{/isCollectionFormatMulti}}
    }

    {{/isListContainer}}
    {{^isListContainer}}
    if (requestParameters.{{paramName}} !== undefined) {
      formParams.append('{{baseName}}', requestParameters.{{paramName}} as any);
    }

    {{/isListContainer}}
    {{/formParams}}
    {{/hasFormParams}}
    return this.createFetchParams({
      path: `{{{path}}}`{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String(requestParameters.{{paramName}}))){{/pathParams}},
      method: '{{httpMethod}}',
      headers: headerParameters,
      query: queryParameters,
      {{#hasBodyParam}}
      {{#bodyParam}}
      {{#isContainer}}
      body: requestParameters.{{paramName}}{{#isListContainer}}{{#items}}{{^isPrimitiveType}}?.map(typeSerializer.toJsonObject('{{datatype}}')){{/isPrimitiveType}}{{/items}}{{/isListContainer}},
      {{/isContainer}}
      {{^isContainer}}
      {{^isPrimitiveType}}
      body: typeSerializer.toJsonObject('{{dataType}}')(requestParameters.{{paramName}}),
      {{/isPrimitiveType}}
      {{#isPrimitiveType}}
      body: requestParameters.{{paramName}} as any,
      {{/isPrimitiveType}}
      {{/isContainer}}
      {{/bodyParam}}
      {{/hasBodyParam}}
      {{#hasFormParams}}
      body: formParams,
      {{/hasFormParams}}
    });
  }

  /**
   * @throws {APIExceptionError}
   * @throws {APISerializeError}
   */
  async {{nickname}}Response(response: Response): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}> {
    if (response.status >= 200 && response.status < 300) {
      {{#returnType}}
      {{#isResponseFile}}
      return response.blob();
      {{/isResponseFile}}
      {{^isResponseFile}}
      {{#returnTypeIsPrimitive}}
      {{#isMapContainer}}
      return response.json();
      {{/isMapContainer}}
      {{#isListContainer}}
      return response.json();
      {{/isListContainer}}
      {{#returnSimpleType}}
      return response.text().then(value => value as any);
      {{/returnSimpleType}}
      {{/returnTypeIsPrimitive}}
      {{^returnTypeIsPrimitive}}
      {{#isListContainer}}
      return response.json().then(typeSerializer.toValueObjectList('{{returnBaseType}}'));
      {{/isListContainer}}
      {{^isListContainer}}
      {{#isMapContainer}}
      return response.json().then(typeSerializer.toValueObjectMap('{{returnBaseType}}'));
      {{/isMapContainer}}
      {{^isMapContainer}}
      return response.json().then(typeSerializer.toValueObject('{{returnBaseType}}'));
      {{/isMapContainer}}
      {{/isListContainer}}
      {{/returnTypeIsPrimitive}}
      {{/isResponseFile}}
      {{/returnType}}
    } else {
      switch (response.status.toString()) {
        {{#responses}}
        {{^is2xx}}
        {{#baseType}}
        case '{{code}}': // {{message}}
          throw new APIExceptionError({
            exception: typeSerializer.toValueObject('{{baseType}}')(await response.json()),
            message: `{{message}}`,
            response,
          });
        {{/baseType}}
        {{/is2xx}}
        {{/responses}}
        default:
          throw response;
      }
    }
  }

  /**
   * @throws {APIExceptionError}
   * @throws {APISerializeError}
   */
  async {{nickname}}({{#allParams.0}}requestParameters: {{#prefixParameterInterfaces}}{{classname}}{{/prefixParameterInterfaces}}{{operationIdCamelCase}}Request{{/allParams.0}}): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}> {
    const { url, init } = this.{{nickname}}Request({{#allParams.0}}requestParameters{{/allParams.0}});
    const response = await fetch(url, init);

    return this.{{nickname}}Response(response);
  }
  {{/operation}}
}
{{/operations}}

{{#hasEnums}}
{{#operations}}
{{#operation}}
{{#allParams}}
{{#isEnum}}
/**
 * @export
 * @enum {string}
 */
export enum {{operationIdCamelCase}}{{enumName}} {
  {{#allowableValues}}
  {{#enumVars}}
  {{{name}}} = {{{value}}}{{^-last}},{{/-last}}
  {{/enumVars}}
  {{/allowableValues}}
}
{{/isEnum}}
{{/allParams}}
{{/operation}}
{{/operations}}
{{/hasEnums}}

{{#operations}}
{{#operation}}
// {{nickname}}:
//    {{#responses}}
//    code: {{code}}, is1xx: {{is1xx}}, is2xx: {{is2xx}}, is3xx: {{is3xx}}, is4xx: {{is4xx}}, is5xx: {{is5xx}}
//    message: {{message}}
//    dataType: {{dataType}}, baseType: {{baseType}}, containerType: {{containerType}}, simpleType: {{simpleType}}
//    isAnyType: {{isAnyType}}, isBinary: {{isBinary}}, isBoolean: {{isBoolean}}, isByteArray: {{isByteArray}}, isDate: {{isDate}},
//    isDateTime: {{isDateTime}}, isDefault: {{isDefault}}, isDouble: {{isDouble}}, isEmail: {{isEmail}}, isFile: {{isFile}}, isFloat: {{isFloat}},
//    isFreeFormObject: {{isFreeFormObject}}, isInteger: {{isInteger}}, isListContainer: {{isListContainer}}, isLong: {{isLong}}, isMapContainer: {{isMapContainer}},
//    isModel: {{isModel}}, isNumber: {{isNumber}}, isNumeric: {{isNumeric}}, isString: {{isString}}, isUuid: {{isUuid}}
//    {{/responses}}
{{/operation}}
{{/operations}}